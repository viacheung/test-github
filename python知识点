加了冒号后换行会自动有tab
注意匹配引号
1.read() 每次读取整个文件，它通常将读取到底文件内容放到一个字符串变量中，也就是说 .read() 生成文件内容是一个字符串类型。
2.readline()每只读取文件的一行，通常也是读取到的一行内容放到一个字符串变量中，返回str类型。
3.readlines()每次按行读取整个文件内容，将读取到的内容放到一个列表中，返回list类型
read之后要seek(0)
pydoc用来查看命令函数等文档说明
powershell 返回上一级是cd..
清空当前窗口的内容cls
展示当前文件夹的详细信息dir
readline扫描字直到出现\n
float(input())
from sys import argv
import为导入，把python功能库的功能放到脚本里面
argv（argument variable）：当运行脚本，保存了你传给python脚本的参数
argc(argument count) : 
script，first，filename= argv 解包
sys是包，获取argv功能
modules（features）: 模块（库）:你想导入进来让python做更多事情的东西
一行代码如果有两个=，那么内部=可以不用空格隔开
Traceback (most recent call last) : 回溯(最近的调用)
Unicode : Universal  encoding 32个字节 
压缩（compression）编码惯例，使得用 8 个比特
来编码大多数常用字符，并在需要时切换成 16 或 32 个比特这件事成为可能。
recursion：递归
b'原始字节序列'→字符序列
迪拜斯（DBES）Decode Bytes Encode Strings 
有字节要字符串，解码字节：.decode() 
有字符串要字节，编码字符串：.encode()
strip() : 移除字符串头尾指定的字符(默认为空格或换行符)
.truncate()：清空文件 
#.close - 关闭文件，就像编辑器中的 “文件->另存为”一样。
#• read - 读取文件内容。你可以把读取结果赋给一个变量。
#• readline - 只读取文本文件的一行内容。
#• truncate - 清空文件。清空的时候要当心。
#• write('stuff') - 给文件写入一些“东西”。
#• seek(0) - 把读/写的位置移到文件最开头。
字符串外面如果用单引号，里面如果还要用单引号需要加转义字符\
formula = secret_formula(start_point)  返回到formula里面有三个参数
print("We'd have {} beans, {} jars, and {} crates.".format(*formula))
 python语句中的 end=' ' 的作用：为末尾end传递一个空字符串
这样print函数不会在字符串末尾添加一个换行符，而是添加一个空字符串，其实这也是一个语法要求，表示这个语句没结束
range() 函数只处理从第一个到最后一个数，但不包括最后一个数,如range(1, 3)循环2次
element.append() 把东西追加到列表的末尾
for number in the_count ： number自己创建，the_count是一个列表，number分别取列表的各个元素
以下是 range 在 for 中的使用，循环出runoob 的每个字母:
>>>x = 'runoob'
>>> for i in range(len(x)) :
...     print(x[i])
... 
r
u
n
o
o
b
>>>
split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串
split(' 分割标志'，分割次数)
pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。
join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。
假设stuff为一个列表，列表下标从0开始，stuff[-1]表示最后一个
stuff[3:5],表示在stuff数组中下标3的元素和下标不大于5的元素。有点类似于 range(3,5)
a.test("hello")等价于test(a, "hello")
collections.OrderedDict 数据结构-字典有序排列
使用if not x这种写法的前提是：必须清楚x等于None,  False, 空字符串"", 0, 空列表[], 空字典{}, 空元组()时对你的判断没有影响才行
get()  ：返回指定键的值，如果值不在字典中返回默认值，语法：dict.get(key, default=None):
例如：city = cities.get('TX', 'Does Not Exist')#前面是键，后面是值不在字典的默认值
 expected an indented block：期望一个缩进的块
__init__前后应该有两个下划线
random()是不能直接访问的，需要导入 random 模块，然后通过 random 静态对象调用该方法。
random() 方法返回随机生成的一个实数，它在[0,1)范围内。
from urllib.request import urlopen  负责打开浏览url内的html 文本
import sys sys模块包含了与Python解释器和它的环境有关的函数。
sys.argv:给程序传递外部参数，是一个字符串列表，number[0]为脚本名称，后面为程序参数
sys.platform:跨平台，window还是linux
sys.exit(n) sys.path等等
str() 函数将对象转化为适于人阅读的形式。
str.count(sub, start= 0,end=len(string))  用于统计字符串里某个字符或子字符串出现的次数。可选参数为在字符串搜索的开始与结束位置。sub为子字符串
对于random.sample的用法，多用于截取列表的指定长度的随机数，但是不会改变列表本身的排序      另：sample()方法返回一个列表，其中从序列中随机选择指定数量的项目
sample：样本
Python capitalize()将字符串的第一个字母变成大写,其他字母变小写。（借助键盘CAPSLK来理解）
sentence[:5]的操作来获取前5个元素，sentence[5:]来获取第五个元素之后的所有元素，sentence[:]表示取所有
replace() 方法把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次
SyntaxError：语法错误  NameError：命名错误
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
字典 keys() 方法返回一个视图对象。
dict.keys()、dict.values() 和 dict.items() 返回的都是视图对象（ view objects），提供了字典实体的动态视图，这就意味着字典改变，视图也会跟着变化。
视图对象不是列表，不支持索引，可以使用 list() 来转换为列表。
我们不能对视图对象进行任何的修改，因为字典的视图对象都是只读的。
shuffle() 方法将序列的所有元素随机排序。
str()函数转为字符串形式
1，在linux的终端下，ctrl+d代表EOF的作用，ctrl+z表示要让程序后台执行,ctrl+c可以结束程序。
2，在windows的cmd下，只有ctrl+c可以结束程序。
ctrl+d与ctrl+z是没有用的。
3，在windows下输入eof的方法：
在输入时按信alt键不放，然后在小键盘上输入2, 5, 5就是EOF了
EOF一般等于-1，也就是无符号数的255，所以输入-1会有效果
## Dog is-a Animal
class Dog(Animal):
 ## rover is-a Dog
 rover = Dog("Rover")
 ## frank has a pet,rover is-a Dog
frank.pet = rover
Python pass 是空语句，是为了保持程序结构的完整性。 不做任何事情，一般用做占位语句。
Python upper() 方法将字符串中的小写字母转为大写字母。
self指的是实例Instance本身 ，类中的方法的第一个参数一定要是self，而且不能省略。
在 if __name__ == 'main': 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的
self.pet = None 有什么意有什么意义？？ 这样确保 self.pet 这个类的属性被设为默认的 None。
 from 模块名import 方法名     from random import randint
from textwrap import dedent        dedent用来去除用"""表示输出段落时段落前缩进的空白，使得靠左输出。
update() 方法用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。
import 导入模块，每次使用模块中的函数都要是定是哪个模块。
from…import * 导入模块，每次使用模块中的函数，直接使用函数就可以了；注因为已经知道该函数是那个模块中的了。
